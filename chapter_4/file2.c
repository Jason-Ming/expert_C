#include <stdio.h>

extern char *s;
extern int *i;

extern void ps();
extern void printmem(char *p, int length);
void main()
{
    ps();
    //s被解释为指针，s[0]就需要把实际s的值'a'作为地址，在以这个地址加上偏移取值
    //如下打印会出现段错误。
    
    //我们先打印地址看看:address of s in file2:0x636261-0x636262-0x636263-0x636264
    printf("address of s in file2:%p-%p-%p-%p\n", &s[0], &s[1], &s[2], &s[3]);

    //执行下面的打印会出现Segmentation fault (core dumped)
    //通过ulimit -c 1024将core记录设置使能，再执行程序，
    //使用命令 gdb core-file core打印core的内容，
    //发现时访问了非法内存，估计是这个地址是内核保护的内存地址:
    //Core was generated by `./a.out'.
    //Program terminated with signal SIGSEGV, Segmentation fault.
    //#0  0x0049c540 in ?? ()
    printmem(&s[0], 32);
    
    printf("%d-%d-%d-%d\n", s[0], s[1], s[2], s[3]);

    //i被解释为指针，需要把i的值也就是实际数组i[0]的值作为地址，在加上偏移输出
    //而i[0]的值是s的首地址，也就是下面的语句会输出s[0]的内容，而s和i的内存是挨着的
    //所以最终输出是0x636261(s0~s1拼成的int的数值)-0x4da008(s0的地址)-0x2(i1)-0x3(i2)
    printf("0x%x-0x%x-0x%x-0x%x\n", i[0], i[1], i[2], i[3]);
}

